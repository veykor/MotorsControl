#include <PID_v1.h>

//#include <FastPID.h>




#include <TimerOne.h>

#define TIMEBASEMS 10
#define INTPINMOTOR1  2
#define NMOTORS 1
#define BANGBANGFACTOR 0.5


long int FlagCounter = 0;
bool Refresh = false;

long int TimeRefresh = 0;
long int TimeInt[NMOTORS][2];
bool IntActived = false;

void IntRefresh()
{
  TimeRefresh = micros();
  Refresh = true;
}


void FlagDetect()
{
  TimeInt[0][1]=TimeInt[0][0];
  TimeInt[0][0]=micros();
  FlagCounter++;
  IntActived = true;
}

///////////////////////////////////////////////////////////////////Class Motor Unit//////////////////////////////////////////////////////////////////////////////
class motorControl
{
  public:
    motorControl(int timebase);
  
    void begin(int pinTurnClock, int pinTurnAnticlock,int pinEnable,long int *EncoderCounter,int EncoderTickPerTurn,double Kp,double Ki,double Kd);
    double ReadAngularVelocity(); 
    double ReadAngularVelocity2(long int DTimeMicroseconds); 
    void WriteMotor(double ControlSignal);
    

  //private:
    int pTC,pTAc,pE;
    double RadPerPulseAndSecond;
    double RadPerPulse;
    int TurningSense;
    int TimeBasems;

    double WMotor;

    long int *FlagCounter;
   
    void definePin();
};

motorControl::motorControl(int timebase)
{
  this->TimeBasems = timebase;
}


void motorControl::definePin()
{
  pinMode(pTC,OUTPUT);
  pinMode(pTAc,OUTPUT);
  pinMode(pE,OUTPUT);
  digitalWrite(pE,HIGH);
}


void motorControl::begin(int pinTurnClock, int pinTurnAnticlock,int pinEnable,long int *EncoderCounter,int EncoderTickPerTurn,double Kp,double Ki,double Kd)
{
  this->pTC = pinTurnClock;
  this->pTAc = pinTurnAnticlock;
  this->pE = pinEnable;
  RadPerPulse = ((2.0*PI)/(double)EncoderTickPerTurn);
  RadPerPulseAndSecond = RadPerPulse*(1000.0/(double)TimeBasems);
  

  FlagCounter = EncoderCounter;

  definePin();
}

double motorControl::ReadAngularVelocity()
{

  WMotor = (double)TurningSense*(double)FlagCounter[0] * RadPerPulseAndSecond;
  //Serial.print(WMotor);
  //Serial.print(" :--: ");
  FlagCounter[0] = 0;
  return WMotor;
}

double motorControl::ReadAngularVelocity2(long int DTimeMicroseconds)
{
  double WMotor2;
  WMotor2 = ((double)TurningSense*RadPerPulse*1000000)/((double)DTimeMicroseconds);
//  Serial.print(WMotor);
//  Serial.print(" :--: ");
//Serial.print(RadPerPulse,6);
//  Serial.print(" :--: ");
  
  return WMotor2;
}

void motorControl::WriteMotor(double ControlSignal)
{
  int WtempTC = constrain((int)ControlSignal,0,254);
  int WtempTAc = -constrain((int)ControlSignal,-254,0);
  /*Serial.print(pTC);
  Serial.print(" : ");
  Serial.print(WtempTC);
  Serial.print(" : ");
  Serial.print(pTAc);
  Serial.print(" : ");
  Serial.println(WtempTAc);*/
  if(WtempTC > 20 && WtempTAc == 0)
    TurningSense = 1;
  else if(WtempTC == 0 && WtempTAc > 20)
    TurningSense = -1;
  else
  {
    analogWrite(pTC,0);
    analogWrite(pTAc,0);
    return;
  }
    
  
  analogWrite(pTC,WtempTC);
  analogWrite(pTAc,WtempTAc);
  
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////Class Motors///////////////////////////////////////////////////////////////////////////////////
class motorsControl
{
  public:
  motorControl *motor;
  void begin(uint8_t nMotors,int TimeBasems);
  private:
  uint8_t nMotors;
  int TimeBasems;
  
};


void motorsControl::begin(uint8_t nMotors,int TimeBasems)
{
  this->nMotors = nMotors;
  this->TimeBasems = TimeBasems;
  this->motor = new motorControl[nMotors](TimeBasems);

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////Class Joystick//////////////////////////////////////////////////////////////////////////////////
class Joystick
{
  public:
  int x,y,xRaw,yRaw,xInPin,yInPin,xCenterPoint,yCenterPoint;
  int LimxMin,LimxMax,LimyMin,LimyMax;
  int OutxValue,OutyValue;
  
  
  Joystick(int xAnPin,int yAnPin,int OutxMaxValue,int OutyMaxValue);
  //Joystick(int xAnPin,int yAnPin,int xRawMin,int xRawMax,int yRawMin,int yRawMax);
  void ValueRead();
  void TestLimits();
  void Adapter();
  void ConvertValue();
  void setCenter();
  void begin();
  

  
};

Joystick::Joystick(int xAnPin,int yAnPin,int OutxMaxValue,int OutyMaxValue)
{
  this->xInPin = xAnPin;
  this->yInPin = yAnPin;
  this->OutxValue = OutxMaxValue;
  this->OutyValue = OutyMaxValue;
}

void Joystick::ValueRead()
{
  xRaw = analogRead(xInPin)-xCenterPoint;
  yRaw = analogRead(yInPin)-yCenterPoint;
  TestLimits();
  Adapter();
}

void Joystick::setCenter()
{
  xCenterPoint = analogRead(xInPin);
  yCenterPoint = analogRead(yInPin);
  LimxMax = xCenterPoint+100;
  LimxMin = xCenterPoint-100;
  LimyMax = yCenterPoint+100;
  LimyMin = yCenterPoint-100;
}

void Joystick::begin() 
{
  setCenter();
}

void Joystick::TestLimits() 
{
  LimxMax = max(LimxMax,xRaw);
  LimyMax = max(LimyMax,yRaw);
  LimxMin = min(LimxMin,xRaw);
  LimyMin = min(LimyMin,yRaw);
}

void Joystick::Adapter() 
{
  if(xRaw >= 0)
    x = map(xRaw,0,LimxMax,0,OutxValue);
  else
    x = map(xRaw,0,LimxMin,0,-OutxValue);
  if(yRaw >= 0)
    y = map(yRaw,0,LimyMax,0,OutyValue);
  else
    y = map(yRaw,0,LimyMin,0,-OutyValue);  
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct
{
  double Input;
  double Output;
  double SetPoint;
  double Kp;
  double Ki;
  double Kd; 
  
}PidStruct[NMOTORS];


motorsControl MotorsSystem;
Joystick Controller(0,1,10000,10000);
PID PidController(&PidStruct[0].Input,&PidStruct[0].Output,&PidStruct[0].SetPoint,10,50,0.0,DIRECT);

void setup() {

  Serial.begin(250000);

  ////////////////////////////////
  Controller.begin();
  MotorsSystem.begin(NMOTORS,TIMEBASEMS);
  MotorsSystem.motor[0].begin(5,6,7,&FlagCounter,1360,10,62.7352572145546,0);
  PidController.SetMode(AUTOMATIC);
  PidController.SetOutputLimits(-255.0,255.0);

  ////////////////////////////////  

  attachInterrupt(digitalPinToInterrupt(INTPINMOTOR1), FlagDetect, RISING);
  Timer1.initialize(1000*TIMEBASEMS);
  Timer1.attachInterrupt(IntRefresh);

  //digitalWrite(7,HIGH);
  //digitalWrite(6,HIGH);
  digitalWrite(5,LOW);
  
}

void loop() {

if(Refresh)
{
  
  
  //Serial.print(MotorsSystem.motor[0].WMotor);
  //Serial.print(" :--: ");
  Controller.ValueRead();
//  Serial.print(" : ");
//  Serial.print(Controller.x);
//  Serial.print(" : ");
//  Serial.print(Controller.y);
//  Serial.print(" : ");
//  


//  if(IntActived)
//  {
//    Serial.print(TimeInt[0][0]-TimeInt[0][1]);
//    Serial.print(" : ");
//    Serial.print(MotorsSystem.motor[0].ReadAngularVelocity2(TimeInt[0][0]-TimeInt[0][1]));
//    PidStruct[0].Input = MotorsSystem.motor[0].ReadAngularVelocity2(TimeInt[0][0]-TimeInt[0][1]);
//  }    
//  else
//  {
//    Serial.print(TimeRefresh-TimeInt[0][0]);
//    Serial.print(" : ");
//    Serial.print(MotorsSystem.motor[0].ReadAngularVelocity2(TimeInt[0][0]-TimeInt[0][1]));
//    PidStruct[0].Input = MotorsSystem.motor[0].ReadAngularVelocity2(TimeRefresh-TimeInt[0][0]);
//  }
    
 // Serial.print(" : ");
  PidStruct[0].Input = MotorsSystem.motor[0].ReadAngularVelocity();
//  Serial.print(PidStruct[0].Input);
//  Serial.print(" : ");
  PidStruct[0].SetPoint = double(Controller.x)/1000.0;
//  Serial.print(PidStruct[0].SetPoint);
//  Serial.print(" : ");
  PidController.Compute();

  int temp = PidStruct[0].Output;
  //Serial.print(temp);
  MotorsSystem.motor[0].WriteMotor(temp);
  Serial.println("");


//  Serial.print(constrain(200,0,255));
//  Serial.print(" :--: ");
//  Serial.println(-constrain((int)-200.0,-255,0));
//  
//  analogWrite(5,0);
//  analogWrite(6,0);
  /*
  
  
  
  */
  
  /*
  Serial.print(Controller.xRaw);
  Serial.print(" : ");
  Serial.print(Controller.x);
  Serial.print(" : ");
  Serial.print(Controller.yRaw);
  Serial.print(" : ");  
  Serial.print(Controller.y);
  Serial.print(" : ");
  Serial.println(MotorsSystem.motor[0].FlagCounter[0]);
  
  */

   /*
    double SetPointPid;
    double FeedbackPid;
    double OutputPid;
    long int *FlagCounter;
*/

  
  /* loop
  encoderRead();
  joystickRead();
  encoder_to_W();
  joystick_to_W();
  pidAdapter();
  runpid();
  writeMotor();
  */   
  IntActived = false;
  Refresh = false;
}
  
}
