#include <PID_v1.h>

//#include <FastPID.h>




#include <TimerOne.h>

#define TIMEBASEMS 10
#define INTPINMOTOR1  2
#define NMOTORS 1
#define BANGBANGFACTOR 0.5


long int FlagCounter = 0;
bool Refresh = false;


void IntRefresh()
{
  Refresh = true;
}


void FlagDetect()
{
  FlagCounter++;
}

///////////////////////////////////////////////////////////////////Class Motor Unit//////////////////////////////////////////////////////////////////////////////
class motorControl
{
  public:
    motorControl(int timebase);
  
    void begin(int pinTurnClock, int pinTurnAnticlock,int pinEnable,long int *EncoderCounter,int EncoderTickPerTurn,double Kp,double Ki,double Kd);
    double ReadAngularVelocity(); 
    void WriteMotor(double ControlSignal);
    

  //private:
    int pTC,pTAc,pE;
    double RadPerPulseAndSecond;
    int TurningSense;
    int TimeBasems;

    double WMotor;

    long int *FlagCounter;
   
    void definePin();
};

motorControl::motorControl(int timebase)
{
  this->TimeBasems = timebase;
}


void motorControl::definePin()
{
  pinMode(pTC,OUTPUT);
  pinMode(pTAc,OUTPUT);
  pinMode(pE,OUTPUT);
  digitalWrite(pE,HIGH);
}


void motorControl::begin(int pinTurnClock, int pinTurnAnticlock,int pinEnable,long int *EncoderCounter,int EncoderTickPerTurn,double Kp,double Ki,double Kd)
{
  this->pTC = pinTurnClock;
  this->pTAc = pinTurnAnticlock;
  this->pE = pinEnable;
 
  RadPerPulseAndSecond = ((2.0*PI)/(double)EncoderTickPerTurn)*(1000.0/(double)TimeBasems);

  FlagCounter = EncoderCounter;

  definePin();
}

double motorControl::ReadAngularVelocity()
{

  WMotor = (double)TurningSense*(double)FlagCounter[0] * RadPerPulseAndSecond;
  FlagCounter[0] = 0;
  return WMotor;
}


void motorControl::WriteMotor(double ControlSignal)
{
  int WtempTC = constrain((int)ControlSignal,0,254);
  int WtempTAc = -constrain((int)ControlSignal,-254,0);
  /*Serial.print(pTC);
  Serial.print(" : ");
  Serial.print(WtempTC);
  Serial.print(" : ");
  Serial.print(pTAc);
  Serial.print(" : ");
  Serial.println(WtempTAc);*/
  if(WtempTC > 20 && WtempTAc == 0)
    TurningSense = 1;
  else if(WtempTC == 0 && WtempTAc > 20)
    TurningSense = -1;
  else
  {
    analogWrite(pTC,0);
    analogWrite(pTAc,0);
    return;
  }
    
  
  analogWrite(pTC,WtempTC);
  analogWrite(pTAc,WtempTAc);
  
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////Class Motors///////////////////////////////////////////////////////////////////////////////////
class motorsControl
{
  public:
  motorControl *motor;
  void begin(uint8_t nMotors,int TimeBasems);
  private:
  uint8_t nMotors;
  int TimeBasems;
  
};


void motorsControl::begin(uint8_t nMotors,int TimeBasems)
{
  this->nMotors = nMotors;
  this->TimeBasems = TimeBasems;
  this->motor = new motorControl[nMotors](TimeBasems);

}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////Class Joystick//////////////////////////////////////////////////////////////////////////////////
class Joystick
{
  public:
  int x,y,xRaw,yRaw,xInPin,yInPin,xCenterPoint,yCenterPoint;
  int LimxMin,LimxMax,LimyMin,LimyMax;
  int OutxValue,OutyValue;
  
  
  Joystick(int xAnPin,int yAnPin,int OutxMaxValue,int OutyMaxValue);
  //Joystick(int xAnPin,int yAnPin,int xRawMin,int xRawMax,int yRawMin,int yRawMax);
  void ValueRead();
  void TestLimits();
  void Adapter();
  void ConvertValue();
  void setCenter();
  void begin();
  

  
};

Joystick::Joystick(int xAnPin,int yAnPin,int OutxMaxValue,int OutyMaxValue)
{
  this->xInPin = xAnPin;
  this->yInPin = yAnPin;
  this->OutxValue = OutxMaxValue;
  this->OutyValue = OutyMaxValue;
}

void Joystick::ValueRead()
{
  xRaw = analogRead(xInPin)-xCenterPoint;
  yRaw = analogRead(yInPin)-yCenterPoint;
  TestLimits();
  Adapter();
}

void Joystick::setCenter()
{
  xCenterPoint = analogRead(xInPin);
  yCenterPoint = analogRead(yInPin);
  LimxMax = xCenterPoint+100;
  LimxMin = xCenterPoint-100;
  LimyMax = yCenterPoint+100;
  LimyMin = yCenterPoint-100;
}

void Joystick::begin() 
{
  setCenter();
}

void Joystick::TestLimits() 
{
  LimxMax = max(LimxMax,xRaw);
  LimyMax = max(LimyMax,yRaw);
  LimxMin = min(LimxMin,xRaw);
  LimyMin = min(LimyMin,yRaw);
}

void Joystick::Adapter() 
{
  if(xRaw >= 0)
    x = map(xRaw,0,LimxMax,0,OutxValue);
  else
    x = map(xRaw,0,LimxMin,0,-OutxValue);
  if(yRaw >= 0)
    y = map(yRaw,0,LimyMax,0,OutyValue);
  else
    y = map(yRaw,0,LimyMin,0,-OutyValue);  
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct
{
  double Input;
  double Output;
  double SetPoint;
  double Kp;
  double Ki;
  double Kd; 
  
}PidStruct[NMOTORS];


motorsControl MotorsSystem;
Joystick Controller(0,1,10000,10000);
PID PidController(&PidStruct[0].Input,&PidStruct[0].Output,&PidStruct[0].SetPoint,10.0,50.0,0.0,DIRECT);

void setup() {

  Serial.begin(250000);

  ////////////////////////////////
  Controller.begin();
  MotorsSystem.begin(NMOTORS,TIMEBASEMS);
  MotorsSystem.motor[0].begin(5,6,7,&FlagCounter,1360,10,62.7352572145546,0);
  PidController.SetMode(AUTOMATIC);
  PidController.SetOutputLimits(-255.0,255.0);

  ////////////////////////////////  

  attachInterrupt(digitalPinToInterrupt(INTPINMOTOR1), FlagDetect, RISING);
  Timer1.initialize(1000*TIMEBASEMS);
  Timer1.attachInterrupt(IntRefresh);

  digitalWrite(5,LOW);
  
}

void loop() {

if(Refresh)
{

  Controller.ValueRead();

  
  PidStruct[0].Input = MotorsSystem.motor[0].ReadAngularVelocity();

  PidStruct[0].SetPoint = double(Controller.x)/2000.0;

  PidController.Compute();

  int temp = PidStruct[0].Output;
  Serial.println(temp);
  MotorsSystem.motor[0].WriteMotor(temp);

  Refresh = false;
}
  
}
